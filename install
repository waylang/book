#! /bin/bash

# Bootstrap a new Way repo.  Run this in a new repo directory on the OS host.

# This script can be run in a "local" mode which runs provisioning in the calling host.
# It goes without saying DO NOT RUN IT OUTSIDE OF VAGRANT OR TRAVIS IN THIS WAY.

# To enable local mode, set the LOCAL environment variable and run it by name:
# LOCAL=true ~/infrastructure/install

# There is also a test mode, which implies local.  To enable it, set TEST:
# TEST=true ~/infrastructure/install

# The script makes a work directory in $TMPDIR or /tmp, named infrastructure-install.XXXX
# By default it is removed on exit, but for debugging it can be kept by setting KEEP:
# TEST=true KEEP=true ~/infrastructure/install

set -e -u -o pipefail

export TEST="${TEST:-}"
export LOCAL="${LOCAL:-$TEST}"
export KEEP="${KEEP:-}"

# A little color can really spruce up that dreary log spam
function green {
  if [ -z "${NO_COLOR:-}" ]
  then
    echo -e "\033[1;32m$@\033[0m"
  else
    echo "$@"
  fi
}

function red {
  if [ -z "${NO_COLOR:-}" ]
  then
    echo -e "\033[1;31m$@\033[0m"
  else
    echo "$@"
  fi
}

# Report an error to stderr and exit abnormally.
function error {
  red Error: "$@" >&2
  exit 1
}

# We need git and either a vagrant or a ruby
which git >/dev/null || error 'git is not available'

if [ -z "$LOCAL" ]
then
  which vagrant >/dev/null || error 'vagrant is not available'
else
  which ruby >/dev/null || error 'ruby is not available'
fi

# A directory to hold generated files. An inherited value is used by the exec trampoline
if [ -z "${INSTALL_WORK_DIR:-}" ]
then
  export INSTALL_WORK_DIR=$(mktemp -d "${TMPDIR:-/tmp}"/infrastructure-install-XXXX)
fi

# Keep the original location of this script for testing
if [ -z "${ORIGINAL_INSTALL_LOCATION:-}" ] && [ -n "$TEST" ]
then
  export ORIGINAL_INSTALL_LOCATION="${BASH_SOURCE[0]}"
fi

if [ -z "$KEEP" ]
then
  # Clean it up on exit
  trap "sudo rm -rf \"$INSTALL_WORK_DIR\"" EXIT
fi

# The generated project name is taken from the current directory
export PROJECT_DIR=$(pwd)
export PROJECT_NAME=$(basename "$PROJECT_DIR")

# Run a heredoc as ruby.
#
# In live use this runs within vagrant's embedded ruby install.
# In local mode it's just the host's ruby.
function ruby_stdin {
  local ruby_path
  local ruby_file

  ruby_path=$(mktemp "$INSTALL_WORK_DIR/ruby.rb.XXXX")
  ruby_file=$(basename "$ruby_path")

  # This consumes the function's stdin
  cat > "$ruby_path"

  if [ -z "$LOCAL" ]
  then
    # Point vagrant at it and run
    VAGRANT_CWD="$INSTALL_WORK_DIR" VAGRANT_VAGRANTFILE="$ruby_file" vagrant status
  else
    # Use the local ruby
    ruby "$ruby_path"
  fi
}

# Fetch the latest release (or this one for testing), unless we already have
if [ "$0" != "$INSTALL_WORK_DIR/install" ]
then
  ruby_stdin <<RUBY
begin
  require 'net/http'
  require 'json'

  # HTTP GET available in base ruby that follows redirects
  def http_get(uri)
    loop do
      res = Net::HTTP.get_response(URI(uri))
      if res.code =~ /^3/
        uri = res['Location']
      else
        return res.body
      end
    end
  end

  if ENV.key?('TEST') && ENV['TEST'] != ''
    tag_name = 'test'
    install_script = File.read('${BASH_SOURCE[0]}')
  else
    # Where we can find metadata on the latest infrastructure release
    RELEASE_API_URL='https://api.github.com/repos/waylang/infrastructure/releases/latest'

    # JSON description of the latest release
    json_body = JSON.parse(http_get(RELEASE_API_URL))

    # The git tag for this release
    tag_name = json_body.fetch('tag_name')

    # The download (asset) url for this script within the release
    install_script_url = json_body.fetch('assets')
      .select { |asset| asset.fetch('name') == 'install' }
      .map { |asset| asset.fetch('browser_download_url') }
      .first

    raise 'No install script found in latest release' unless install_script_url

    # Get the script body
    install_script = http_get(install_script_url)
  end

  # Write the release version tag to INSTALL_WORK_DIR/tag_name
  File.open("#{ENV['INSTALL_WORK_DIR']}/tag_name", 'w') { |f| f.write(tag_name) }

  # Write the script to INSTALL_WORK_DIR/install
  File.open("#{ENV['INSTALL_WORK_DIR']}/install", 'w') { |f| f.write(install_script) }
rescue => e
  warn "Error: Could not retrieve install script from latest release (#{e})"
  exit 1
else
  exit 0
end
RUBY

  # Execute the latest release version of this script
  chmod +x "$INSTALL_WORK_DIR/install"

  [ -z "$TEST" ] && exec "$INSTALL_WORK_DIR/install"
fi

# We're now running the latest release version of this script.
tag_name="$(< "$INSTALL_WORK_DIR/tag_name")"

green "Installing infrastructure $tag_name into $PROJECT_NAME"

git init
mkdir -p {provisioning,vendor}

if [ -n "$TEST" ]
then
  ln -sfT $(cd $(dirname "$ORIGINAL_INSTALL_LOCATION") && pwd) vendor/infrastructure
else
  # Vendor in the latest release version of infrastructure
  ssh -T -o StrictHostKeyChecking=no git@github.com </dev/null || true

  if [ ! -d vendor/infrastructure ]
  then
    git submodule add https://github.com/waylang/infrastructure.git vendor/infrastructure
  fi

  git submodule update --init --recursive
  (cd vendor/infrastructure; git checkout "$tag_name")
  git submodule update --init --recursive
  git add vendor/infrastructure
fi

# Render just enough of the the included templates to bootstrap
ruby_stdin <<'RUBY'
begin
  # The project name
  PROJECT_NAME = ENV['PROJECT_NAME']

  # The relative location of the templates
  if PROJECT_NAME == 'infrastructure'
    TEMPLATES = 'templates/'
  else
    TEMPLATES = 'vendor/infrastructure/templates/'
  end

  def render_if_absent(path, context = {})
    safe = context.inject({}) do |c, pair|
      k, v = *pair
      k = k.to_s
      raise ArgumentError, "#{k} is not snake case" unless k =~ /^[a-zA-Z_]+$/
      c[k.upcase] = v
      c
    end

    template_path = TEMPLATES + path
    template = File.read(template_path)

    pattern = Regexp.new("@(#{safe.keys.sort.join('|')})@")
    rendered = template.gsub(pattern) { |match| safe[$1] }
    File.open(path, 'w') { |f| f.write rendered } unless File.exist? path
  end

  render_if_absent 'Vagrantfile', project_name: PROJECT_NAME
  render_if_absent 'provisioning/common', project_name: PROJECT_NAME
  render_if_absent 'provisioning/vagrant', project_name: PROJECT_NAME
rescue => e
  warn "Error: Could not bootstrap vagrant (#{e})"
  exit 1
else
  exit 0
end
RUBY

if [ -z "$LOCAL" ]
then
  # Fire up the real vagrant to generate the rest
  vagrant up --no-color
else
  bash provisioning/vagrant
fi

# Add the generated files to the git staging area.
git add -A

echo
green "Successfully generated $PROJECT_NAME with infrastructure $tag_name."
echo
green "I've staged the generated code but not committed it."

if [ -z "$LOCAL" ]
then
  green "I also left the vagrant instance running, 'vagrant halt' to turn it off."
fi
