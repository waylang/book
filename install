#! /bin/bash
# vim: filetype=sh

# Copyright (C) 2016-2016 Philip H. Smith

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Bootstrap a new Way repo.  Run this in a new repo directory on the OS host.

# This script can be run in a "local" mode which runs provisioning in the calling host.
# It goes without saying DO NOT RUN IT OUTSIDE OF VAGRANT OR TRAVIS IN THIS WAY.

# To enable local mode, set the LOCAL environment variable and run it by name:
# LOCAL=true ~/infrastructure/install

# There is also a test mode, which implies local.  To enable it, set TEST:
# TEST=true ~/infrastructure/install

# By default existing files are not over-written.  To force files to be over-written, set
# FORCE: LOCAL=true FORCE=true ~/infrastructure/install

# The script makes a work directory in $TMPDIR or /tmp, named infrastructure-install.XXXX
# By default it is removed on exit, but for debugging it can be kept by setting KEEP:
# TEST=true KEEP=true ~/infrastructure/install

set -e -u -o pipefail

export TEST="${TEST:-}"
export LOCAL="${LOCAL:-$TEST}"
export FORCE="${FORCE:-}"
export KEEP="${KEEP:-}"

# A little color can really spruce up that dreary log spam
function green {
  if [ "${NO_COLOR:-}" != 'true' ]
  then
    echo -e "\033[1;32m$@\033[0m"
  else
    echo "$@"
  fi
}

function red {
  if [ "${NO_COLOR:-}" != 'true' ]
  then
    echo -e "\033[1;31m$@\033[0m"
  else
    echo "$@"
  fi
}

# Report an error to stderr and exit abnormally.
function error {
  red Error: "$@" >&2
  exit 1
}

# We need git and either a vagrant or a ruby
which git >/dev/null || error 'git is not available'

if [ "$LOCAL" == 'true' ]
then
  which ruby >/dev/null || error 'ruby is not available'
else
  which vagrant >/dev/null || error 'vagrant is not available'
fi

# A directory to hold generated files. An inherited value is used by the exec trampoline
if [ -z "${INSTALL_WORK_DIR:-}" ]
then
  export INSTALL_WORK_DIR=$(mktemp -d "${TMPDIR:-/tmp}"/infrastructure-install-XXXX)
fi

# Keep the original location of this script for local execution
if [ -z "${ORIGINAL_INSTALL_LOCATION:-}" ] && [ "$LOCAL" == 'true' ]
then
  export ORIGINAL_INSTALL_LOCATION="${BASH_SOURCE[0]}"
fi

if [ "$KEEP" != 'true' ]
then
  # Clean it up on exit
  trap "rm -rf \"$INSTALL_WORK_DIR\"" EXIT
fi

# The generated project name is taken from the current directory
export PROJECT_DIR=$(pwd)
export PROJECT_NAME=$(basename "$PROJECT_DIR")

if [ "$PROJECT_NAME" != 'infrastructure' ]
then
  export INFRASTRUCTURE="$PROJECT_DIR/vendor/infrastructure"
  export RELATIVE_INFRASTRUCTURE='vendor/infrastructure'
else
  export INFRASTRUCTURE="$PROJECT_DIR"
  export RELATIVE_INFRASTRUCTURE='.'
fi

# Run a heredoc as ruby.
#
# In live use this runs within vagrant's embedded ruby install.
# In local mode it's just the host's ruby.
function ruby_stdin {
  local ruby_path
  local ruby_file

  ruby_path=$(mktemp "$INSTALL_WORK_DIR/ruby.rb.XXXX")
  ruby_file=$(basename "$ruby_path")

  # This consumes the function's stdin
  cat > "$ruby_path"

  if [ "$LOCAL" == 'true' ]
  then
    # Use the local ruby
    ruby "$ruby_path"
  else
    # Point vagrant at it and run
    VAGRANT_CWD="$INSTALL_WORK_DIR" VAGRANT_VAGRANTFILE="$ruby_file" vagrant status
  fi
}

# Fetch the latest release (or this one for testing), unless we already have
if [ "$0" != "$INSTALL_WORK_DIR/install" ]
then
  ruby_stdin <<'RUBY'
begin
  require 'net/http'
  require 'json'

  # HTTP GET available in base ruby that follows redirects
  def http_get(uri)
    loop do
      res = Net::HTTP.get_response(URI(uri))
      if res.code =~ /^3/
        uri = res['Location']
      else
        return res.body
      end
    end
  end

  if ENV['LOCAL'] == 'true'
    tag_name = 'local'
    install_script = File.read(ENV['ORIGINAL_INSTALL_LOCATION'])
  else
    # Where we can find metadata on the latest infrastructure release
    RELEASE_API_URL='https://api.github.com/repos/waylang/infrastructure/releases/latest'

    # JSON description of the latest release
    json_body = JSON.parse(http_get(RELEASE_API_URL))

    # The git tag for this release
    tag_name = json_body.fetch('tag_name')

    # The download (asset) url for this script within the release
    install_script_url = json_body.fetch('assets')
      .select { |asset| asset.fetch('name') == 'install' }
      .map { |asset| asset.fetch('browser_download_url') }
      .first

    raise 'No install script found in latest release' unless install_script_url

    # Get the script body
    install_script = http_get(install_script_url)
  end

  # Write the release version tag to INSTALL_WORK_DIR/tag_name
  File.open("#{ENV['INSTALL_WORK_DIR']}/tag_name", 'w') { |f| f.write(tag_name) }

  # Write the script to INSTALL_WORK_DIR/install
  File.open("#{ENV['INSTALL_WORK_DIR']}/install", 'w') { |f| f.write(install_script) }
rescue => e
  warn "Error: Could not retrieve install script from latest release (#{e})"
  exit 1
else
  exit 0
end
RUBY

  # Execute the latest release version of this script
  chmod +x "$INSTALL_WORK_DIR/install"

  [ "$LOCAL" != 'true' ] && exec "$INSTALL_WORK_DIR/install"
fi

# We're now running the latest release version of this script.
tag_name="$(< "$INSTALL_WORK_DIR/tag_name")"

green "Installing infrastructure $tag_name into $PROJECT_NAME"

git init
mkdir -p provisioning

if [ "$PROJECT_NAME" == 'infrastructure' ]
then
  git submodule update --init --recursive
elif [ "$TEST" == 'true' ]
then
  mkdir -p vendor
  ln -sfT $(cd $(dirname "$ORIGINAL_INSTALL_LOCATION") && pwd) vendor/infrastructure
elif ! [ "$LOCAL" == 'true' ]
then
  # Local non-test runs are assumed to be in-place resets, no need to re-vendor

  mkdir -p vendor

  # Vendor in the latest release version of infrastructure
  ssh -T -o StrictHostKeyChecking=no git@github.com </dev/null || true

  if [ ! -d vendor/infrastructure ]
  then
    git submodule add https://github.com/waylang/infrastructure.git vendor/infrastructure
  fi

  git submodule update --init --recursive
  (cd vendor/infrastructure; git checkout "$tag_name")
  git submodule update --init --recursive
  git add vendor/infrastructure
fi

# Render just enough of the the included templates to bootstrap
ruby_stdin <<'RUBY'
begin
  # The project name
  INFRASTRUCTURE = ENV['INFRASTRUCTURE']
  PROJECT_NAME = ENV['PROJECT_NAME']
  RELATIVE_INFRASTRUCTURE = ENV['RELATIVE_INFRASTRUCTURE']

  # The relative location of the templates
  if PROJECT_NAME == 'infrastructure'
    TEMPLATES = 'templates/'
  else
    TEMPLATES = 'vendor/infrastructure/templates/'
  end

  def render(path, context = {})
    safe = context.inject({}) do |c, pair|
      k, v = *pair
      k = k.to_s
      raise ArgumentError, "#{k} is not snake case" unless k =~ /^[a-zA-Z_]+$/
      c[k.upcase] = v
      c
    end

    template_path = TEMPLATES + path
    template = File.read(template_path)

    pattern = Regexp.new("@(#{safe.keys.sort.join('|')})@")
    rendered = template.gsub(pattern) { |match| safe[$1] }
    if !File.exist?(path) || ENV['FORCE'] == 'true'
      File.open(path, 'w') { |f| f.write rendered }
    end
  end

  render 'Vagrantfile', project_name: PROJECT_NAME,
    relative_infrastructure: RELATIVE_INFRASTRUCTURE
  render 'provisioning/common'
  render 'provisioning/vagrant', relative_infrastructure: RELATIVE_INFRASTRUCTURE
rescue => e
  warn "Error: Could not bootstrap vagrant (#{e})"
  exit 1
else
  exit 0
end
RUBY

if [ "$LOCAL" == 'true' ]
then
  bash provisioning/vagrant
else
  # Fire up the real vagrant to generate the rest
  vagrant up --no-color
fi

# Add the generated files to the git staging area.
git add -A

echo
green "Successfully generated $PROJECT_NAME with infrastructure $tag_name."
echo
green "I've staged the generated code but not committed it."

if [ "$LOCAL" != 'true' ]
then
  green "I also left the vagrant instance running, 'vagrant halt' to turn it off."
fi
